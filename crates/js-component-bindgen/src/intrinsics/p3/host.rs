//! Intrinsics that represent helpers that implement async calls

use crate::intrinsics::Intrinsic;
use crate::intrinsics::component::ComponentIntrinsic;
use crate::intrinsics::p3::async_task::AsyncTaskIntrinsic;
use crate::source::Source;

/// This enum contains intrinsics that implement async calls
#[derive(Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]
#[allow(clippy::enum_variant_names)]
pub enum HostIntrinsic {
    /// Intrinsic used by the host to prepare trampoline calls
    ///
    /// # Host Intrinsic implementation function
    ///
    /// The function that implements this intrinsic has the following definition:
    ///
    /// ```ts
    /// type i32 = number;
    /// function prepareCall(memoryIdx: i32): boolean;
    /// ```
    ///
    PrepareCall,

    /// Intrinsic used by the host to signal the start of an async-lowered call
    ///
    /// This intrinsic signals the start of an Async call emitted by modules generated
    /// by wasmtime's Fused Adapter Compiler of Trampolines (FACT)
    ///
    /// This call indicates that an async-lowered import function is being called
    /// (that has either been async lifted or not on the callee side)
    ///
    /// This intrinsic returns a combination of the initial call status and optionally
    /// the handle to a waitable that should be awaited until it's time to (if necessary),
    /// packed into the same u32.
    ///
    /// # Host Intrinsic implementation function
    ///
    /// The function that implements this intrinsic has the following definition:
    ///
    /// ```ts
    /// type i32 = number;
    /// type u32 = number;
    /// type u64 = number;
    /// type Args = {
    ///     postReturnIdx: number | null,
    ///     getPostReturnFn: () => function | null,
    ///     callbackIdx: number | null,
    ///     getCallbackFn: () => function | null,
    /// };
    /// function asyncStartCall(args: Args, callee: function, paramCount: u32, resultCount: u32, flags: u32): u32;
    /// ```
    ///
    /// NOTE: args are gathered during Trampoline, and the rest of the arguments are fed in.
    ///
    AsyncStartCall,

    /// Start of an sync call emitted by modules generated by wasmtime's
    /// Fused Adapter Compiler of Trampolines (FACT)
    ///
    /// This call maps indicates a trampoline for a sync-lowered import
    /// of an async-lifted export, meaning that the *calling* component
    /// has sync lowered, but the callee has async lifted
    ///
    /// this intrinsic signals the start of an sync-lowered call
    /// of an async-lifted export.
    ///
    /// # Host Intrinsic implementation function
    ///
    /// The function that implements this intrinsic has the following definition:
    ///
    /// ```ts
    /// type i32 = number;
    /// function syncStartCall(callbackIdx: i32): boolean;
    /// ```
    ///
    SyncStartCall,
}

impl HostIntrinsic {
    /// Retrieve dependencies for this intrinsic
    pub fn deps() -> &'static [&'static Intrinsic] {
        &[]
    }

    /// Retrieve global names for this intrinsic
    pub fn get_global_names() -> impl IntoIterator<Item = &'static str> {
        ["syncStartCall", "asyncStartCall", "prepareCall"]
    }

    /// Get the name for the intrinsic
    pub fn name(&self) -> &'static str {
        match self {
            Self::PrepareCall => "_prepareCall",
            Self::AsyncStartCall => "_asyncStartCall",
            Self::SyncStartCall => "_syncStartCall",
        }
    }

    /// Render an intrinsic to a string
    pub fn render(&self, output: &mut Source) {
        match self {
            // PrepareCall is called before an async-lowered import (from the host or another component)
            // is called from inside a component.
            //
            // It's primary function is to set up a Subtask which will be used by the callee.
            // see: https://github.com/WebAssembly/component-model/blob/main/design/mvp/Async.md#structured-concurrency
            //
            // NOTE: it's possible for PrepareCall to be combined with AsyncStartCall
            // in a future component model release.
            //
            Self::PrepareCall => {
                let debug_log_fn = Intrinsic::DebugLog.name();
                let prepare_call_fn = Self::PrepareCall.name();
                let current_task_get_fn =
                    Intrinsic::AsyncTask(AsyncTaskIntrinsic::GetCurrentTask).name();
                let create_new_current_task_fn =
                    Intrinsic::AsyncTask(AsyncTaskIntrinsic::CreateNewCurrentTask).name();
                output.push_str(&format!(
                  r#"
                    function {prepare_call_fn}(
                        memoryIdx,
                        getMemoryFn,
                        startFn,
                        returnFn,
                        callerInstanceIdx,
                        calleeInstanceIdx,
                        taskReturnTypeIdx, //19
                        stringEncoding,
                        resultCountOrAsync,
                    ) {{
                        {debug_log_fn}('[{prepare_call_fn}()]', {{
                            callerInstanceIdx,
                            calleeInstanceIdx,
                            taskReturnTypeIdx,
                            stringEncoding,
                            resultCountOrAsync,
                        }});
                        const argArray = [...arguments];

                        // Since Rust will happily pass large u32s over, resultCountOrAsync should be one of:
                        // (a) u32 max size     => callee is async fn with no result
                        // (b) u32 max size - 1 => callee is async fn with result
                        // (c) any other value  => callee is sync with the given result count
                        //
                        // Due to JS handling the value as 2s complement, the `resultCountOrAsync` ends up being:
                        // (a) -1 as u32 max size
                        // (b) -2 as u32 max size - 1
                        // (c) x
                        //
                        // Due to JS mishandling the value as 2s complement, the actual values we get are:
                        // see. https://github.com/wasm-bindgen/wasm-bindgen/issues/1388
                        let isAsync = false;
                        let hasResultPointer = false;
                        if (resultCountOrAsync === -1) {{
                            isAsync = true;
                            hasResultPointer = false;
                        }} else if (resultCountOrAsync === -2) {{
                            isAsync = true;
                            hasResultPointer = true;
                        }}

                        const currentCallerTaskMeta = {current_task_get_fn}(callerInstanceIdx);
                        if (!currentCallerTaskMeta) {{
                            throw new Error('invalid/missing current task for caller during prepare call');
                        }}

                        const currentCallerTask = currentCallerTaskMeta.task;
                        if (!currentCallerTask) {{
                            throw new Error('unexpectedly missing task in meta for caller during prepare call');
                        }}

                        if (currentCallerTask.componentIdx() !== callerInstanceIdx) {{
                            throw new Error(`task component idx [${{ currentCallerTask.componentIdx() }}] !== [${{ callerInstanceIdx }}] (callee ${{ calleeInstanceIdx }})`);
                        }}

                        // TODO: support indirect params based on storagePtr/args
                        const directParams = true;
                        let getCalleeParamsFn;
                        let resultPtr = null;
                        if (directParams) {{
                            if (hasResultPointer) {{
                                const directParamsArr = argArray.slice(10);
                                getCalleeParamsFn = () => directParamsArr;
                                resultPtr = argArray[9];
                            }} else {{
                                const directParamsArr = argArray.slice(9);
                                getCalleeParamsFn = () => directParamsArr;
                            }}
                        }} else {{
                            if (memoryIdx === null) {{
                                throw new Error('memory idx not supplied to prepare depsite indirect params being used');
                            }}
                            throw new Error(`indirect parameter loading not yet supported`);
                        }}

                        let encoding;
                        switch (stringEncoding) {{
                            case 0:
                                encoding = 'utf8';
                                break;
                            case 1:
                                encoding = 'utf16';
                                break;
                            case 2:
                                encoding = 'compact-utf16';
                                break;
                            default:
                                throw new Error(`unrecognized string encoding enum [${{stringEncoding}}]`);
                        }}

                        const [newTask, newTaskID] = {create_new_current_task_fn}({{
                            componentIdx: calleeInstanceIdx,
                            isAsync,
                            getCalleeParamsFn,
                            // TODO: find a way to pass the import name through here
                            entryFnName: 'task/' + currentCallerTask.id() + '/new-prepare-task',
                            stringEncoding,
                        }});

                        const subtask = currentCallerTask.createSubtask({{
                           componentIdx: callerInstanceIdx,
                           parentTask: currentCallerTask,
                           childTask: newTask,
                           callMetadata: {{
                              memory: getMemoryFn(),
                              memoryIdx,
                              resultPtr,
                              returnFn,
                              startFn,

                              // TODO: Add lower fn metas (entitySize + lower fn) for the result!

                           }}
                        }});

                        newTask.setParentSubtask(subtask);
                        // TODO: This isn't really a return memory idx for the caller, it's for checking
                        // against the task.return (which will be called from the callee)
                        newTask.setReturnMemoryIdx(memoryIdx);
                    }}
              "#
                ));
            }

            // AsyncStartCall is called just before an async-lowered import from component "A"
            // is called from inside component "B" (both host->guest and guest->guest calls).
            //
            // We don't need to do much here, because async `Task`s are created during execution of
            // CallWasm/CallInterface, rather than here.
            //
            Self::AsyncStartCall => {
                let debug_log_fn = Intrinsic::DebugLog.name();
                let async_start_call_fn = Self::AsyncStartCall.name();
                let current_async_task_id_globals =
                    AsyncTaskIntrinsic::GlobalAsyncCurrentTaskIds.name();
                let current_component_idx_globals =
                    AsyncTaskIntrinsic::GlobalAsyncCurrentComponentIdxs.name();
                let current_task_get_fn =
                    Intrinsic::AsyncTask(AsyncTaskIntrinsic::GetCurrentTask).name();
                let get_or_create_async_state_fn =
                    Intrinsic::Component(ComponentIntrinsic::GetOrCreateAsyncState).name();
                let async_event_code_enum = Intrinsic::AsyncEventCodeEnum.name();
                let async_driver_loop_fn =
                    Intrinsic::AsyncTask(AsyncTaskIntrinsic::DriverLoop).name();
                let subtask_class =
                    Intrinsic::AsyncTask(AsyncTaskIntrinsic::AsyncSubtaskClass).name();
                let global_component_memories_class =
                    Intrinsic::GlobalComponentMemoriesClass.name();

                // TODO: lower here for non-zero param count
                // https://github.com/bytecodealliance/wasmtime/blob/69ef9afc11a2846248c9e94affca0223dbd033fc/crates/wasmtime/src/runtime/component/concurrent.rs#L1775
                output.push_str(&format!(r#"
                    function {async_start_call_fn}(args, callee, paramCount, resultCount, flags) {{
                        const {{ getCallbackFn, callbackIdx, getPostReturnFn, postReturnIdx }} = args;
                        {debug_log_fn}('[{async_start_call_fn}()] args', args);

                        const taskMeta = {current_task_get_fn}({current_component_idx_globals}.at(-1), {current_async_task_id_globals}.at(-1));
                        if (!taskMeta) {{ throw new Error('invalid/missing current async task meta during prepare call'); }}

                        const argArray = [...arguments];

                        // NOTE: at this point we know the current task is the one that was started
                        // in PrepareCall, so we *should* be able to pop it back off and be left with
                        // the previous task
                        const preparedTask = taskMeta.task;
                        if (!preparedTask) {{ throw new Error('unexpectedly missing task in task meta during prepare call'); }}

                        if (resultCount < 0 || resultCount > 1) {{ throw new Error('invalid/unsupported result count'); }}

                        const callbackFnName = 'callback_' + callbackIdx;
                        const callbackFn = getCallbackFn();
                        preparedTask.setCallbackFn(callbackFn, callbackFnName);
                        preparedTask.setPostReturnFn(getPostReturnFn());

                        const subtask = preparedTask.getParentSubtask();

                        if (resultCount < 0 || resultCount > 1) {{ throw new Error(`unsupported result count [${{ resultCount }}]`); }}

                        const params = preparedTask.getCalleeParams();
                        if (paramCount !== params.length) {{
                            throw new Error(`unexpected param count [${{ paramCount }}], expected [${{ expectedParamCount }}]`);
                        }}

                        subtask.setOnProgressFn(() => {{
                            subtask.setPendingEventFn(() => {{
                                if (subtask.resolved()) {{ subtask.deliverResolve(); }}
                                return {{
                                    code: {async_event_code_enum}.SUBTASK,
                                    index: rep,
                                    result: subtask.getStateNumber(),
                                }}
                            }});
                        }});

                        const subtaskState = subtask.getStateNumber();
                        if (subtaskState < 0 || subtaskState > 2**5) {{
                            throw new Error('invalid subtask state, out of valid range');
                        }}

                        const callerComponentState = {get_or_create_async_state_fn}(subtask.componentIdx());
                        const rep = callerComponentState.subtasks.insert(subtask);
                        subtask.setRep(rep);

                        const calleeComponentState = {get_or_create_async_state_fn}(preparedTask.componentIdx());
                        const calleeBackpressure = calleeComponentState.hasBackpressure();

                        // Set up a handler on subtask completion to lower results from the call into the caller's memory region.
                        //
                        // NOTE: during fused guest->guest calls this handler is triggered, but does not actually perform
                        // lowering manually, as fused modules provider helper functions that can
                        subtask.registerOnResolveHandler((res) => {{
                            {debug_log_fn}('[{async_start_call_fn}()] handling subtask result', {{ res, subtaskID: subtask.id() }});
                            let subtaskCallMeta = subtask.getCallMetadata();

                            // NOTE: in the case of guest -> guest async calls, there may be no memory/realloc present,
                            // as the host will intermediate the value storage/movement between calls.
                            //
                            // We can simply take the value and lower it as a parameter
                            if (subtaskCallMeta.memory || subtaskCallMeta.realloc) {{
                                throw new Error("call metadata unexpectedly contains memory/realloc for guest->guest call");
                            }}

                            const callerTask = subtask.getParentTask();
                            const calleeTask = preparedTask;
                            const callerMemoryIdx = callerTask.getReturnMemoryIdx();
                            const callerComponentIdx = callerTask.componentIdx();

                            // If a helper function was provided we are likely in a fused guest->guest call,
                            // and the result will be delivered (lift/lowered) via helper function
                            if (subtaskCallMeta.returnFn) {{
                                {debug_log_fn}('[{async_start_call_fn}()] return function present while ahndling subtask result, returning early (skipping lower)');
                                    return;
                            }}

                            // If there is no where to lower the results, exit early
                            if (!subtaskCallMeta.resultPtr) {{
                                {debug_log_fn}('[{async_start_call_fn}()] no result ptr during subtask result handling, returning early (skipping lower)');
                                return;
                            }}

                            let callerMemory;
                            if (callerMemoryIdx) {{
                                callerMemory = {global_component_memories_class}.getMemory(callerComponentIdx, callerMemoryIdx);
                            }} else {{
                                const callerMemories = {global_component_memories_class}.getMemoriesForComponentIdx(callerComponentIdx);
                                if (callerMemories.length != 1) {{ throw new Error(`unsupported amount of caller memories`); }}
                                callerMemory = callerMemories[0];
                            }}

                            if (!callerMemory) {{
                                throw new Error(`missing memory for to guest->guest call result (subtask [${{subtask.id()}}])`);
                            }}

                            const lowerFns = calleeTask.getReturnLowerFns();
                            if (!lowerFns || lowerFns.length === 0) {{
                                throw new Error(`missing result lower metadata for guest->guests call (subtask [${{subtask.id()}}])`);
                            }}

                            if (lowerFns.length !== 1) {{
                                throw new Error(`only single result supported for guest->guest calls (subtask [${{subtask.id()}}])`);
                            }}

                            lowerFns[0]({{
                                realloc: undefined,
                                memory: callerMemory,
                                vals: [res],
                                storagePtr: subtaskCallMeta.resultPtr,
                                componentIdx: callerComponentIdx
                            }});

                        }});

                        subtask.onStart({{ startFnParams: params  }});

                        preparedTask.registerOnResolveHandler((res) => {{
                            {debug_log_fn}('[{async_start_call_fn}()] signaling subtask completion due to task completion', {{
                                childTaskID: preparedTask.id(),
                                subtaskID: subtask.id(),
                                parentTaskID: subtask.getParentTask().id(),
                            }});
                            subtask.onResolve(res);
                        }});

                        {debug_log_fn}("[{async_start_call_fn}()] initial call", {{
                            task: preparedTask.id(),
                            subtaskID: subtask.id(),
                            calleeFnName: callee.name,
                        }});

                        let callbackResult = callee();

                        {debug_log_fn}("[{async_start_call_fn}()] after initial call", {{
                            task: preparedTask.id(),
                            subtaskID: subtask.id(),
                            calleeFnName: callee.name,
                        }});

                        const doSubtaskResolve = () => {{
                            subtask.deliverResolve();
                        }};

                        // If a single call resolved the subtask and there is no backpressure in the guest,
                        // we can return immediately
                        if (subtask.resolved() && !calleeBackpressure) {{
                            {debug_log_fn}("[{async_start_call_fn}()] instantly resolved", {{
                                calleeComponentIdx: preparedTask.componentIdx(),
                                task: preparedTask.id(),
                                subtaskID: subtask.id(),
                                callerComponentIdx: subtask.componentIdx(),
                            }});

                            // If a fused component return function was specified for the subtask,
                            // we've likely already called it during resolution of the task.
                            //
                            // In this case, we do not want to actually return 2 AKA "RETURNED",
                            // but the normal started task state, because the fused component expects to get
                            // the waitable + the original subtask state (0 AKA "STARTING")
                            //
                            if (subtask.getCallMetadata().returnFn) {{
                                return Number(subtask.waitableRep()) << 4 | subtaskState;
                            }}

                            doSubtaskResolve();
                            return {subtask_class}.State.RETURNED;
                        }}

                        // Start the (event) driver loop that will resolve the task
                        new Promise(async (resolve, reject) => {{
                            if (subtask.resolved() && calleeBackpressure) {{
                                await calleeComponentState.waitForBackpressure();

                                {debug_log_fn}("[{async_start_call_fn}()] instantly resolved after cleared backpressure", {{
                                    calleeComponentIdx: preparedTask.componentIdx(),
                                    task: preparedTask.id(),
                                    subtaskID: subtask.id(),
                                    callerComponentIdx: subtask.componentIdx(),
                                }});
                                doSubtaskResolve();
                                return;
                            }}

                            const started = await preparedTask.enter();
                            if (!started) {{
                                {debug_log_fn}('[{async_start_call_fn}()] task failed early', {{
                                    taskID: preparedTask.id(),
                                    subtaskID: subtask.id(),
                                }});
                                throw new Error("task failed to start");
                                return;
                            }}

                            // TODO: retrieve/pass along actual fn name the callback corresponds to
                            // (at least something like `<lifted fn name>_callback`)
                            const fnName = [
                                '<task ',
                                subtask.parentTaskID(),
                                '/subtask ',
                                subtask.id(),
                                '/task ',
                                preparedTask.id(),
                                '>',
                            ].join("");

                            try {{
                              {debug_log_fn}("[{async_start_call_fn}()] starting driver loop", {{ fnName, componentIdx: preparedTask.componentIdx(), }});
                                await {async_driver_loop_fn}({{
                                    componentState: calleeComponentState,
                                    task: preparedTask,
                                    fnName,
                                    isAsync: true,
                                    callbackResult,
                                    resolve,
                                    reject
                                }});
                            }} catch (err) {{
                                {debug_log_fn}("[AsyncStartCall] drive loop call failure", {{ err }});
                            }}

                        }});

                        return Number(subtask.waitableRep()) << 4 | subtaskState;
                    }}
                "#));
            }

            Self::SyncStartCall => {
                let debug_log_fn = Intrinsic::DebugLog.name();
                let sync_start_call_fn = Self::SyncStartCall.name();
                output.push_str(&format!(
                    "
                    function {sync_start_call_fn}(callbackIdx) {{
                        {debug_log_fn}('[{sync_start_call_fn}()] args', {{ callbackIdx }});
                        throw new Error('synchronous start call not implemented!');
                    }}
                "
                ));
            }
        }
    }
}
