// @ts-ignore
import { readFile } from 'node:fs/promises';
// @ts-ignore
import { readFileSync } from 'node:fs';
// @ts-ignore
import { stdout, stderr } from 'node:process';
// @ts-ignore
import { basename } from 'node:path';

// This is a helper function used from `host.ts` test in the `tests/runtime/*`
// directory to pass as the `instantiateCore` argument to the `instantiate`
// function generated by `wit-bindgen`.
//
// This function loads the module named by `path` and instantiates it with the
// `imports` object provided. The `path` is a relative path to a wasm file
// within the generated directory.
export async function loadWasm(path: string) {
    const name = basename(path).replace(/\.core\d*\.wasm$/, '');
    const buf = await readFile(new URL(`./${name}/${path}`, import.meta.url));
    return await WebAssembly.compile(buf.buffer as ArrayBuffer);
}

// Just like `loadWasm`, but not async :-).
export function loadWasmSync(path: string) {
    const name = basename(path).replace(/\.core\d*\.wasm$/, '');
    const buf = readFileSync(new URL(`./${name}/${path}`, import.meta.url));
    return new WebAssembly.Module(buf.buffer as ArrayBuffer);
}

// Export a WASI interface directly for instance imports
export function log(bytes: Uint8Array) {
    stdout.write(bytes);
}
export function logErr(bytes: Uint8Array) {
    stderr.write(bytes);
}

export const wasi = {
    'wasi:cli/stderr': {
        getStderr() {},
    },
    'wasi:cli/stdin': {
        getStdin() {},
    },
    'wasi:cli/stdout': {
        getStdout() {},
    },
    'wasi:filesystem/preopens': {
        getDirectories() {},
    },
    'wasi:filesystem/types': {
        Descriptor: class Descriptor {},
        filesystemErrorCode() {
            return 0;
        },
    },
    'wasi:io/error': {
        Error: class WasiError {},
    },
    'wasi:io/streams': {
        InputStream: class InputStream {},
        OutputStream: class OutputStream {},
    },
};
