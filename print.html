<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>jco</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="transpiling.html"><strong aria-hidden="true">2.</strong> Transpiling</a></li><li class="chapter-item expanded "><a href="example.html"><strong aria-hidden="true">3.</strong> Example</a></li><li class="chapter-item expanded "><a href="#.html"><strong aria-hidden="true">4.</strong> Contributor Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">4.1.</strong> Contributing to the Codebase</a></li><li class="chapter-item expanded "><a href="contributing-docs.html"><strong aria-hidden="true">4.2.</strong> Contributing to Docs</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">jco</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>jco</code> is a fully native tool for working with <a href="https://component-model.bytecodealliance.org/design/components.html">WebAssembly Components</a> in JavaScript.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<ul>
<li><a href="./transpiling.html">Transpiling</a> Wasm Component binaries into <a href="https://nodejs.org/api/esm.html#modules-ecmascript-modules">ECMAScript modules</a> that can run in any JavaScript environment.</li>
<li>WASI Preview2 support in Node.js &amp; browsers (experimental).</li>
<li>Component builds of Wasm Tools helpers, available for use as a library or CLI commands for use in native JS environments</li>
<li>Optimization helper for Components via Binaryen.</li>
<li><code>componentize</code> command to easily create components written in JavaScript (wrapper of <a href="https://github.com/bytecodealliance/ComponentizeJS">ComponentizeJS</a>).</li>
</ul>
<blockquote>
<p>Note: This is an experimental project. <strong>No guarantees</strong> are provided for stability, security or support and breaking changes may be made without notice.</p>
</blockquote>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>To contribute to the codebase of the project, refer to the <a href="./contributing.html">Contributor guide</a>.</p>
<p>To contribute to the documentation, refer to the <a href="./contributing-docs.html">Contributor guide</a>.</p>
<p>If you find a mistake, omission, ambiguity, or other problem, please let us know via <a href="https://github.com/bytecodealliance/jco/issues">GitHub issues</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transpiling"><a class="header" href="#transpiling">Transpiling</a></h1>
<p>Components can be transpiled in two separate modes:</p>
<ul>
<li>ESM Integration (default)</li>
<li><a href="transpiling.html#instantiation">Instantiation</a> - async or sync</li>
</ul>
<p>When using the default direct ESM transpilation mode, the output file is a JavaScript module, which imports the component imports,
and exports the component exports.</p>
<p><a href="transpiling.html#instantiation">Instantiation mode</a> allows dynamically providing the imports for the component instantiation, as well as for instantiating a component multiple times.</p>
<p>For the default output, you will likely want to ensure there is a package.json file with a <code>{ &quot;type&quot;: &quot;module&quot; }</code> set for Node.js ES module support (although this is not needed for browser module loading or JS build tooling).</p>
<h2 id="export-conventions"><a class="header" href="#export-conventions">Export Conventions</a></h2>
<p>Components can represent both bundles of modules and individual modules. Compponents export the direct export interface as well as the canonical named interface for the implementation to represent both of these cases.</p>
<p>For example a component that imports an interface will be output as:</p>
<pre><code class="language-js">export { interface, interface as 'my:pkg/interface@version' }
</code></pre>
<p>The exact version allows for disambiguation when a component exports multiple interfaces with the same name but different versions.</p>
<p>If not needing this disambiguation feature, and since support for string exports in JS can be limited, this feature can be disabled with the <code>--no-namespaced-exports</code> flag to instead output only:</p>
<pre><code class="language-js">export { interface }
</code></pre>
<h2 id="import-conventions"><a class="header" href="#import-conventions">Import Conventions</a></h2>
<p>When using the ESM integration default transpilation output bindings are output directly in the <code>registry:name/interface</code> form, but with versions removed.</p>
<p>For example an import to <code>my:pkg/interface@1.2.3</code> will become an import to <code>import { fn } from 'my:pkg/interface';</code>.</p>
<h3 id="map-configuration"><a class="header" href="#map-configuration">Map Configuration</a></h3>
<p>To customize the import specifiers used in JS, a <code>--map</code> configuration can be provided to the transpilation operation to convert the imports.</p>
<p>For example, <code>jco transpile component.wasm --map my:pkg/interface@1.2.3=./myinterface.js</code> will instead output <code>import { fn } from './myinterface.js'</code>.</p>
<p>Where the file <code>myinterface.js</code> would contain the function that is being imported from the interface:</p>
<pre><code class="language-js">export function fn () {
  // .. function implementation ..
}
</code></pre>
<p>Map configuration also supports <code>#</code> targets, which means that the interface can be read off of a nested JS object export.</p>
<p>For example with a JS file written:</p>
<pre><code class="language-js">export const interface = {
  fn () {
    // exported function to be imported from my:pkg/interface
  }
}
</code></pre>
<p>We can map the interface directly to this object instead of the entire module using the map configuration:</p>
<pre><code>jco transpile component.wasm --map my:pkg/interface@1.2.3=./mypkg.js#interface
</code></pre>
<p>This way a single JS file can define multiple interfaces together.</p>
<p>Furthermore, wildcard mappings are also supported so that using (and quoting for bash compatibility):</p>
<pre><code>jco transpile component.wasm --map 'my:pkg/*@1.2.3=./mypkg.js#*'
</code></pre>
<p>we can map all interfaces into a single JS file reading them off of exported objects for those interfaces.</p>
<h3 id="wasi-shims"><a class="header" href="#wasi-shims">WASI Shims</a></h3>
<p>WASI is given special treatment and is automatically mapped to the <code>@bytecodealliance/preview2-shim</code> npm package, with interfaces imported off of the relevant subsystem.</p>
<p>Using the above rules, this is effectively provided by the default map configuration which is always automatically provided:</p>
<pre><code>jco transpile component.wasm --map wasi:cli/*@0.2.0=@bytecodealliance/preview2-shim/cli#*
</code></pre>
<p>For all subsystems - <code>cli</code>, <code>clocks</code>, <code>filesystem</code>, <code>http</code>, <code>io</code>, <code>random</code> and <code>sockets</code>.</p>
<p>To disable this automatic WASI handling the <code>--no-wasi-shim</code> flag can be provided and WASI will be treated like any other import without special handling.</p>
<h3 id="interface-implementation-example"><a class="header" href="#interface-implementation-example">Interface Implementation Example</a></h3>
<p>Here's an example of implementing a custom WIT interface in JavaScript:</p>
<p>example.wit</p>
<pre><code class="language-wit">package test:pkg;
interface interface-types {
  type some-type = list&lt;u32&gt;;
  record some-record {
    some-field: some-type
  }
}
interface iface {
  use interface-types.{some-record};
  interface-fn: func(%record: some-record) -&gt; result&lt;string, string&gt;;
}
world myworld {
  import iface;
  export test: func() -&gt; string;
}
</code></pre>
<p>When transpiling, we can use the map rules as described in the previous section to implement all interfaces from a single JS file.</p>
<p>Given a component compiled for this world, we could transpile it, but given this is only an example, we can use the <code>--stub</code> feature of transpile to inspect the bindings:</p>
<pre><code>jco transpile example.wit --stub -o output --map 'test:pkg/*=./imports.js#*'
</code></pre>
<p>The <code>output/example.js</code> file contains the generated bindgen:</p>
<pre><code class="language-js">import { iface } from './imports.js';
const { interfaceFn } = iface;

// ... bindings ...

function test () {
  // ...
}

export { test }
</code></pre>
<p>Therefore, we can implement this mapping of the world with the following JS file:</p>
<p>imports.js</p>
<pre><code class="language-js">export const iface = {
  interfaceFn (record) {
    return 'string';
  }
};
</code></pre>
<blockquote>
<p>Note: Top-level results are turned into JS exceptions, all other results are treated as tagged objects <code>{ tag: 'ok' | 'err', val }</code>.</p>
</blockquote>
<h3 id="wasi-proposals"><a class="header" href="#wasi-proposals">WASI Proposals</a></h3>
<p><strong>JCO will always take PRs to support all open WASI proposals.</strong></p>
<p>These PRs can be implemented by extending the <a href="https://github.com/bytecodealliance/jco/blob/main/src/cmd/transpile.js#L110">default map configuration provided by JCO</a> to support the new <code>--map wasi:subsytem/*=shimpkg/subsystem#*</code> for the WASI subsystem being implemented.</p>
<blockquote>
<p><code>shimpkg</code> in the above refers to a published npm package implementation to install per JS ecosystem conventions. This way, polyfill packages can be published to npm.</p>
</blockquote>
<p>Upstreaming into the <a href="https://github.com/bytecodealliance/jco/tree/main/packages/preview2-shim">@bytecodealliance/preview2-shim</a> package is also possible for WASI proposals that have progressed to Phase 1 in the <a href="https://github.com/WebAssembly/WASI/blob/main/Proposals.md">WASI proposal stage process</a>.</p>
<h2 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h2>
<p>Instantiation output is enabled via <code>jco transpile component.wasm --instantiation sync|async</code>.</p>
<p>When using instantiation mode, the output is a JS module with a single <code>instantiate()</code> function.</p>
<p>For async instantiation, the instantiate function takes the following signature:</p>
<pre><code class="language-ts">export async function instantiate(
  getCoreModule: (path: string) =&gt; Promise&lt;WebAssembly.Module&gt;,
  imports: {
    [importName: string]: any
  },
  instantiateCore?: (module: WebAssembly.Module, imports: Record&lt;string, any&gt;) =&gt; Promise&lt;WebAssembly.Instance&gt;
): Promise&lt;{ [exportName: string]: any }&gt;;
</code></pre>
<p><code>imports</code> allows customizing the imports provided for instantiation.</p>
<p><code>instantiateCore</code> defaults to <code>WebAssembly.instantiate</code>.</p>
<p><code>getCoreModule</code> can typically be implemented as:</p>
<pre><code class="language-ts">export async function getCoreModule(path: string) {
  return await WebAssembly.compile(await readFile(new URL(`./${path}`, import.meta.url)));
}
</code></pre>
<p>For synchronous instantiation, the instantiate function has the following signature:</p>
<pre><code class="language-ts">export function instantiate(
  getCoreModule: (path: string) =&gt; WebAssembly.Module,
  imports: {
    [importName: string]: any
  },
  instantiateCore?: (module: WebAssembly.Module, imports: Record&lt;string, any&gt;) =&gt; WebAssembly.Instance
): Promise&lt;{ [exportName: string]: any }&gt;;
</code></pre>
<p>Where instead of promises, all functions are synchronous.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="jco-example-workflow"><a class="header" href="#jco-example-workflow">jco Example Workflow</a></h2>
<p>Given an existing Wasm Component, <code>jco</code> provides the tooling necessary to work with this Component fully natively in JS.</p>
<p>For an example, consider a Component <code>cowsay.wasm</code>:</p>
<pre><code class="language-shell">- cowsay.wasm
</code></pre>
<p>Where we would like to use and run this Component in a JS environment.</p>
<h3 id="inspecting-component-wit"><a class="header" href="#inspecting-component-wit">Inspecting Component WIT</a></h3>
<p>As a first step, we might like to look instead this binary black box of a Component and see what it actually does.</p>
<p>To do this, we can use <code>jco wit</code> to extract the &quot;WIT world&quot; of the Component (<a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md">WIT</a> is the typing language used for defining Components).</p>
<pre><code class="language-shell">&gt; jco wit cowsay.wasm
world cowsay {
  export cow: interface {
    enum cows {
      default,
      cheese,
      daemon,
      dragon-and-cow,
      dragon,
      elephant-in-snake,
      elephant,
      eyes,
      flaming-sheep
    }

    say: func(text: string, cow: option&lt;cows&gt;) -&gt; string;
  }
}
</code></pre>
<p>From the above we can see that this Component exports a <code>cow</code> interface with a single function export, <code>say</code>, taking as input a string, an optional cow, and returning a string.</p>
<p>Alternatively <code>jco print cowsay.wasm -o out.wat</code> would output the full concrete Wasm WAT to inspect the Component, with all the implementation details (don't forget the <code>-o</code> flag...).</p>
<h3 id="transpiling-to-js"><a class="header" href="#transpiling-to-js">Transpiling to JS</a></h3>
<p>To execute the Component in a JS environment, use the <code>jco transpile</code> command to generate the JS for the Component:</p>
<pre><code class="language-shell">&gt; jco transpile cowsay.wasm --minify -o cowsay

Transpiled JS Component Files:

 - cowsay/cowsay.core.wasm      2.01 MiB
 - cowsay/cowsay.d.ts           0.73 KiB
 - cowsay/cowsay.js             6.01 KiB
</code></pre>
<p>Now the Component can be directly imported and used as an ES module:</p>
<p>test.mjs</p>
<pre><code class="language-js">import { cow } from './cowsay/cowsay.js';

console.log(cow.say('Hello Wasm Components!'));
</code></pre>
<p>The above JavaScript can be executed in Node.js:</p>
<pre><code class="language-shell">&gt; node test.mjs

 ________________________
&lt; Hello Wasm Components! &gt;
 ------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
</code></pre>
<p>Or it can be executed in a browser via a module script:</p>
<pre><code class="language-html">&lt;script type=&quot;module&quot; src=&quot;test.mjs&quot;&gt;&lt;/script&gt;
</code></pre>
<p>There are a number of custom transpilation options available, detailed in the <a href="README.html#API">API section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributor-guide"><a class="header" href="#contributor-guide">Contributor Guide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing-to-the-codebase"><a class="header" href="#contributing-to-the-codebase">Contributing to the Codebase</a></h1>
<p>Development is based on a standard <code>npm install &amp;&amp; npm run build &amp;&amp; npm run test</code> workflow.</p>
<p>Tests can be run without bundling via <code>npm run build:dev &amp;&amp; npm run test:dev</code>.</p>
<p>Specific tests can be run adding the mocha <code>--grep</code> / <code>-g</code> flag, for example: <code>npm run test:dev -- --grep exports_only</code>.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Required prerequisites for building jco include:</p>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Latest stable Rust</a> with the <code>wasm32-wasi</code> target</li>
<li>Node.js 18+ &amp; npm (https://nodejs.org/en)</li>
</ul>
<h3 id="rust-toolchain"><a class="header" href="#rust-toolchain">Rust Toolchain</a></h3>
<p>The latest Rust stable toolchain can be installed using <a href="https://rustup.rs/">rustup</a>.</p>
<p>Specifically:</p>
<pre><code class="language-shell">rustup toolchain install stable
rustup target add wasm32-wasi
</code></pre>
<p>In case you do not have <code>rustup</code> installed on your system, please follow the installation instructions on the <a href="https://www.rust-lang.org/tools/install">official Rust website</a> based on your operating system</p>
<h2 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h2>
<p>jco is effectively a monorepo consisting of the following projects:</p>
<ul>
<li><code>crates/js-component-bindgen</code>: Rust crate for creating JS component bindgen, published under https://crates.io/crates/js-component-bindgen.</li>
<li><code>crates/js-component-bindgen-component</code>: Component wrapper crate for the component bindgen. This allows bindgen to be self-hosted in JS.</li>
<li><code>crates/wasm-tools-component</code>: Component wrapper crate for wasm-tools, allowing jco to invoke various Wasm toolchain functionality and also make it available through the jco API.</li>
<li><code>src/api.js</code>: The jco API which can be used as a library dependency on npm. Published as https://npmjs.org/package/@bytecodealliance/jco.</li>
<li><code>src/jco.js</code>: The jco CLI. Published as https://npmjs.org/package/@bytecodealliance/jco.</li>
<li><code>packages/preview2-shim</code>: The WASI Preview2 host implementations for Node.js &amp; browsers. Published as https://www.npmjs.com/package/@bytecodealliance/preview2-shim.</li>
</ul>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>To build jco, run:</p>
<pre><code>npm install
npm run build
</code></pre>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>There are three test suites in jco:</p>
<ul>
<li><code>npm run test</code>: Project-level transpilation, CLI &amp; API tests.</li>
<li><code>npm run test --workspace packages/preview2-shim</code>: <code>preview2-shim</code> unit tests.</li>
<li><code>test/browser.html</code>: Bare-minimum browser validation test.</li>
<li><code>cargo test</code>: Wasmtime preview2 conformance tests (not currently passing).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><code>jco</code> is a <a href="https://bytecodealliance.org/">Bytecode Alliance</a> project and follows the Bytecode Alliance's <a href="https://raw.githubusercontent.com/bytecodealliance/jco/main/CODE_OF_CONDUCT.md">Code of Conduct</a> and <a href="https://raw.githubusercontent.com/bytecodealliance/jco/main/ORG_CODE_OF_CONDUCT.md">Organizational Code of Conduct</a>.</p>
<h2 id="using-this-repository"><a class="header" href="#using-this-repository">Using this repository</a></h2>
<p>You can run the website locally using the <a href="https://rust-lang.github.io/mdBook/index.html">mdBook</a> command line tool.</p>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>To use this repository, you need <a href="https://rust-lang.github.io/mdBook/guide/installation.html">mdBook</a> installed on your workstation.</p>
<h2 id="running-the-website-locally"><a class="header" href="#running-the-website-locally">Running the website locally</a></h2>
<p>After installing mdBook, on GitHub, click the <code>Fork</code> button in the upper-right area of the screen to create a copy of the jco repository in your account. This copy is called a fork.</p>
<p>Next, clone it locally by executing the command below.</p>
<pre><code class="language-shell">git clone https://github.com/bytecodealliance/jco/
cd docs
</code></pre>
<p>To build and test the site locally, run:</p>
<pre><code class="language-shell">mdbook serve --open
</code></pre>
<h2 id="submitting-changes"><a class="header" href="#submitting-changes">Submitting Changes</a></h2>
<ul>
<li>Follow the instructions above to <a href="./contributing-docs.html#running-the-website-locally">make changes to your website locally</a>.</li>
<li>When you are ready to submit those changes, go to your fork and create a new pull request to let us know about it.</li>
</ul>
<p>Everyone is welcome to submit a pull request! Once your pull request is created, we'll try to get to reviewing it or responding to it in at most a few days. As the owner of the pull request, it is your responsibility to modify your pull request to address the feedback that has been provided to you by the reviewer.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
